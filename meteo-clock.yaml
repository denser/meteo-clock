esphome:
  name: meteo-clock
  friendly_name: Метео-часы
  name_add_mac_suffix: false
  project:
    name: esphome.meteo-clock
    version: "1.3"  # Обновил версию

esp32:
  board: esp32-c6-devkitc-1
  variant: esp32c6
  flash_size: 8MB
  framework:
    type: esp-idf
    sdkconfig_options:
      CONFIG_ESPTOOLPY_FLASHSIZE_8MB: y

esp32_ble_tracker:

bluetooth_proxy:
  active: true

# WiFi подключение
wifi:
  id: wifi_sta
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    id: wifi_ap
    ssid: "Meteo-Clock"
    password: !secret ap_password
  on_connect:
    then:
      - logger.log: "✅ WiFi подключен"
      - lambda: |-
          id(ha_time).update();  // принудительная синхронизация

captive_portal:

web_server:
  port: 80
  version: 3
  auth:
    username: admin
    password: !secret web_server_password
  include_internal: true
  local: true
  ota: false

# API для Home Assistant
api:
  encryption:
    key: !secret api_encryption_key

ota:
  platform: esphome
  password: !secret ota_password

logger:
  level: DEBUG
  initial_level: WARN  # начальный уровень при загрузке (можно менять через HA)
  logs:
    logger: INFO
    web_server: DEBUG

# Время из Home Assistant
time:
  - platform: homeassistant
    id: ha_time
    timezone: Asia/Krasnoyarsk
    on_time_sync:
      then:
        - logger.log: "✅ Время синхронизировано с Home Assistant"

# I2C для датчиков и дисплея
i2c:
  - id: bus_a
    sda: GPIO6
    scl: GPIO7
    scan: true
    frequency: 100kHz

# UART для MH-Z19
uart:
  - id: uart_1
    tx_pin: GPIO4
    rx_pin: GPIO3
    baud_rate: 9600

# ========== КНОПКИ УПРАВЛЕНИЯ ==========
button:
  - platform: template
    name: "Калибровка CO₂ (20 мин на воздухе)"
    id: calibrate_co2_button
    entity_category: diagnostic
    icon: "mdi:chemical-weapon"
    on_press:
      then:
        - logger.log: "▶️ Запуск калибровки нуля MH-Z19"
        - mhz19.calibrate_zero: mhz19_sensor

# ========== ДАТЧИКИ ==========
sensor:
  # BME280
  - platform: bme280_i2c
    i2c_id: bus_a
    address: 0x76
    temperature:
      id: bme_temperature
      name: "Температура (сырая)"
      unit_of_measurement: "°C"
      accuracy_decimals: 1
      state_class: measurement
      device_class: temperature
      internal: true  # Скрываем сырую температуру из HA
    pressure:
      id: bme_pressure
      name: "Давление"
      unit_of_measurement: "mmHg"
      accuracy_decimals: 1
      state_class: measurement
      device_class: pressure
      filters:
        - lambda: return x * 0.75006168278;
    humidity:
      id: bme_humidity
      name: "Влажность"
      unit_of_measurement: "%"
      accuracy_decimals: 0
      state_class: measurement
      device_class: humidity
    update_interval: 10s

  # Откалиброванная температура
  - platform: template
    id: calibrated_temperature
    name: "Температура"
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    state_class: measurement
    device_class: temperature
    lambda: |-
      return id(bme_temperature).state + id(temp_offset);

  # MH-Z19 CO2
  - platform: mhz19
    id: mhz19_sensor
    uart_id: uart_1
    co2:
      id: mhz19_co2
      name: "CO2"
      unit_of_measurement: "ppm"
      accuracy_decimals: 0
      state_class: measurement
      device_class: carbon_dioxide
    update_interval: 30s
    automatic_baseline_calibration: false

  # Фоторезистор
  - platform: adc
    id: photo_sensor
    name: "Освещенность"
    pin: GPIO1
    attenuation: 12db
    update_interval: 5s
    filters:
      - lambda: return x * 1000;
    unit_of_measurement: "lx"
    accuracy_decimals: 0
    state_class: measurement
    device_class: illuminance

# ========== КНОПКА ==========
binary_sensor:
  - platform: gpio
    id: button_pin
    name: "Кнопка"
    pin:
      number: GPIO0
      inverted: true
      mode:
        input: true
        pullup: true
    filters:
      - delayed_on_off: 10ms
    on_press:
      then:
        - lambda: |-
            std::string current = id(display_mode).current_option();
            std::string next;
            if (current == "Все показания") next = "Крупно время";
            else if (current == "Крупно время") next = "Крупно CO2";
            else if (current == "Крупно CO2") next = "Таблица символов 1";
            else if (current == "Таблица символов 1") next = "Таблица символов 2";
            else if (current == "Таблица символов 2") next = "Таблица символов 3";
            else next = "Все показания";
            id(display_mode).make_call().set_option(next).perform();
            id(update_display_if_needed).execute();

# ========== ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ ==========
globals:
  - id: last_hour
    type: int
    restore_value: false
    initial_value: '-1'
  - id: last_minute
    type: int
    restore_value: false
    initial_value: '-1'
  - id: last_temp
    type: float
    restore_value: false
    initial_value: '-100'
  - id: last_hum
    type: int
    restore_value: false
    initial_value: '-1'
  - id: last_press
    type: int
    restore_value: false
    initial_value: '-1'
  - id: last_co2
    type: int
    restore_value: false
    initial_value: '-1'
  - id: last_mode
    type: int
    restore_value: false
    initial_value: '-1'
  - id: temp_offset
    type: float
    restore_value: true
    initial_value: '0.0'
  - id: abc_enabled
    type: bool
    restore_value: true
    initial_value: 'true'  # По умолчанию ABC включена

# ========== СКРИПТЫ ==========
script:
  - id: update_display_if_needed
    then:
      - lambda: |-
          if (!id(my_lcd).is_ready()) {
            static unsigned long last_log = 0;
            if (millis() - last_log > 60000) {
              ESP_LOGD("display", "Дисплей не готов, ожидание...");
              last_log = millis();
            }
            return;
          }

          auto time = id(ha_time).now();
          bool time_valid = time.is_valid();
          
          bool need_update = false;
          std::string reason = "";
          
          // Получаем текущий режим из select
          std::string mode_str = id(display_mode).current_option();
          int current_mode = 0;
          if (mode_str == "Все показания") current_mode = 0;
          else if (mode_str == "Крупно время") current_mode = 1;
          else if (mode_str == "Крупно CO2") current_mode = 2;
          else if (mode_str == "Таблица символов 1") current_mode = 3;
          else if (mode_str == "Таблица символов 2") current_mode = 4;
          else if (mode_str == "Таблица символов 3") current_mode = 5;
          else current_mode = 0;
          
          // Проверка времени (час и минута) - только для режимов с датчиками
          if (time_valid && current_mode <= 2) {
            if (time.hour != id(last_hour)) {
              id(last_hour) = time.hour;
              need_update = true;
              reason += "час ";
              ESP_LOGD("display", "Изменился час");
            }
            if (time.minute != id(last_minute)) {
              id(last_minute) = time.minute;
              need_update = true;
              reason += "минута ";
              ESP_LOGD("display", "Изменилась минута");
            }
          }
          
          // Проверка режима экрана
          if (current_mode != id(last_mode)) {
            id(last_mode) = current_mode;
            need_update = true;
            reason += "режим ";
            ESP_LOGD("display", "Изменился режим экрана");
          }
          
          // Проверка датчиков (только для режимов с датчиками)
          if (current_mode <= 2) {
            // Температура с коррекцией
            float raw_temp = id(bme_temperature).state;
            float temp = raw_temp + id(temp_offset);
            if (abs(temp - id(last_temp)) > 0.1) {
              id(last_temp) = temp;
              need_update = true;
              reason += "температура ";
              ESP_LOGD("display", "Изменилась температура (корр: %.1f, сырая: %.1f)", temp, raw_temp);
            }
            
            int hum = (int)id(bme_humidity).state;
            if (hum != id(last_hum)) {
              id(last_hum) = hum;
              need_update = true;
              reason += "влажность ";
              ESP_LOGD("display", "Изменилась влажность");
            }
            
            int press = (int)id(bme_pressure).state;
            if (press != id(last_press)) {
              id(last_press) = press;
              need_update = true;
              reason += "давление ";
              ESP_LOGD("display", "Изменилось давление");
            }
            
            float co2_val = id(mhz19_co2).state;
            int co2 = isnan(co2_val) ? 400 : (int)co2_val;
            if (co2 != id(last_co2)) {
              id(last_co2) = co2;
              need_update = true;
              reason += "CO2 ";
              ESP_LOGD("display", "Изменился CO2");
            }
          }
          
          // Обновляем дисплей только если что-то изменилось
          if (need_update) {
            id(my_lcd).update();
            if (!reason.empty()) {
              ESP_LOGD("display", "✅ Дисплей обновлен (причина: %s)", reason.c_str());
            } else {
              ESP_LOGD("display", "✅ Дисплей обновлен");
            }
          }

  - id: update_led
    then:
      - lambda: |-
          float brightness = id(led_brightness).state / 100.0;
          std::string mode_str = id(led_mode_select).current_option();
          std::string source = id(led_source).current_option();
          
          light::LightState *target_led;
          if (source == "Внешний RGB") {
            target_led = id(rgb_led);
          } else {
            target_led = id(builtin_rgb);
          }
          
          static std::string last_mode = "";
          static float last_co2 = -1;
          static float last_hum = -1;
          static float last_temp = -1;
          static int last_color = -1;
          
          int current_color = -1;
          bool changed = false;
          
          if (mode_str == "CO2") {
            float co2_val = id(mhz19_co2).state;
            float co2 = isnan(co2_val) ? 400 : co2_val;
            
            if (co2 >= 1500) {
              current_color = 0;
              target_led->turn_on().set_rgb(1.0, 0.0, 0.0).set_brightness(brightness).perform();
            } else if (co2 >= 1000) {
              current_color = 1;
              target_led->turn_on().set_rgb(1.0, 0.5, 0.0).set_brightness(brightness).perform();
            } else {
              current_color = 2;
              target_led->turn_on().set_rgb(0.0, 1.0, 0.0).set_brightness(brightness).perform();
            }
            
            if (mode_str != last_mode || abs(co2 - last_co2) > 50 || current_color != last_color) {
              changed = true;
              ESP_LOGD("led", "CO2: %s (%.0f)", 
                       current_color == 0 ? "красный" : (current_color == 1 ? "оранжевый" : "зеленый"), 
                       co2);
              last_co2 = co2;
            }
            
          } else if (mode_str == "Влажность") {
            float hum = id(bme_humidity).state;
            
            if (hum <= 20) {
              current_color = 0;
              target_led->turn_on().set_rgb(1.0, 0.0, 0.0).set_brightness(brightness).perform();
            } else if (hum <= 30) {
              current_color = 1;
              target_led->turn_on().set_rgb(1.0, 1.0, 0.0).set_brightness(brightness).perform();
            } else if (hum >= 80) {
              current_color = 2;
              target_led->turn_on().set_rgb(0.0, 0.0, 1.0).set_brightness(brightness).perform();
            } else {
              current_color = 3;
              target_led->turn_on().set_rgb(0.0, 1.0, 0.0).set_brightness(brightness).perform();
            }
            
            if (mode_str != last_mode || abs(hum - last_hum) > 5 || current_color != last_color) {
              changed = true;
              ESP_LOGD("led", "Влажность: %s (%.0f%%)", 
                       current_color == 0 ? "красный" : 
                       (current_color == 1 ? "желтый" : 
                       (current_color == 2 ? "синий" : "зеленый")), 
                       hum);
              last_hum = hum;
            }
            
          } else {
            // Температура с коррекцией для LED
            float raw_temp = id(bme_temperature).state;
            float temp = raw_temp + id(temp_offset);
            
            if (temp >= 30) {
              current_color = 0;
              target_led->turn_on().set_rgb(1.0, 0.0, 0.0).set_brightness(brightness).perform();
            } else if (temp >= 25) {
              current_color = 1;
              target_led->turn_on().set_rgb(1.0, 0.5, 0.0).set_brightness(brightness).perform();
            } else if (temp <= 15) {
              current_color = 2;
              target_led->turn_on().set_rgb(0.0, 0.0, 1.0).set_brightness(brightness).perform();
            } else {
              current_color = 3;
              target_led->turn_on().set_rgb(0.0, 1.0, 0.0).set_brightness(brightness).perform();
            }
            
            if (mode_str != last_mode || abs(temp - last_temp) > 1.0 || current_color != last_color) {
              changed = true;
              ESP_LOGD("led", "Температура: %s (%.1f°C, корр: %.1f)", 
                       current_color == 0 ? "красный" : 
                       (current_color == 1 ? "оранжевый" : 
                       (current_color == 2 ? "синий" : "зеленый")), 
                       temp, id(temp_offset));
              last_temp = temp;
            }
          }
          
          last_mode = mode_str;
          last_color = current_color;
          
          if (!changed) {
            ESP_LOGV("led", "Нет изменений цвета LED");
          }

# ========== НАСТРОЙКИ (УПРАВЛЕНИЕ ИЗ HA) ==========
select:
  # Режим экрана
  - platform: template
    id: display_mode
    name: "Режим экрана"
    entity_category: config
    icon: "mdi:monitor-dashboard"
    optimistic: true
    restore_value: true
    options:
      - "Все показания"
      - "Крупно время"
      - "Крупно CO2"
      - "Таблица символов 1"
      - "Таблица символов 2"
      - "Таблица символов 3"
    initial_option: "Все показания"
    set_action:
      then:
        - lambda: |-
            id(update_display_if_needed).execute();

  # Режим индикатора
  - platform: template
    id: led_mode_select
    name: "Режим индикатора"
    entity_category: config
    icon: "mdi:palette"
    optimistic: true
    options:
      - "CO2"
      - "Влажность"
      - "Температура"
    initial_option: "CO2"
    set_action:
      then:
        - lambda: |-
            id(update_led).execute();

  # Источник индикатора
  - platform: template
    id: led_source
    name: "Источник индикатора"
    entity_category: config
    icon: "mdi:led-outline"
    optimistic: true
    restore_value: true
    options:
      - "Внешний RGB"
      - "Встроенный"
    initial_option: "Встроенный"
    set_action:
      then:
        - lambda: id(update_led).execute();

  # Встроенный селектор для уровня логирования
  - platform: logger
    name: "Уровень журнала"
    id: logger_level_select

number:
  - platform: template
    id: lcd_brightness
    name: "Яркость экрана"
    entity_category: config
    icon: "mdi:brightness-6"
    unit_of_measurement: "%"
    min_value: 10
    max_value: 100
    step: 5
    optimistic: false
    restore_value: true
    initial_value: 80
    set_action:
      then:
        - lambda: |-
            auto call = id(lcd_backlight).turn_on();
            call.set_brightness(x / 100.0);
            call.perform();
            ESP_LOGD("number", "Яркость экрана сохранена: %.0f", x);

  - platform: template
    id: led_brightness
    name: "Яркость индикатора"
    entity_category: config
    icon: "mdi:led-variant"
    unit_of_measurement: "%"
    min_value: 0
    max_value: 100
    step: 5
    optimistic: false
    restore_value: true
    initial_value: 50
    set_action:
      then:
        - lambda: |-
            id(update_led).execute();
            ESP_LOGD("number", "Яркость индикатора сохранена: %.0f", x);

  # Калибровка температуры
  - platform: template
    id: temp_offset_setting
    name: "Коррекция температуры"
    entity_category: config
    icon: "mdi:thermometer-plus"
    unit_of_measurement: "°C"
    min_value: -5.0
    max_value: 5.0
    step: 0.1
    optimistic: false
    set_action:
      then:
        - lambda: |-
            // Обновляем глобальную переменную
            id(temp_offset) = x;
            // Отправляем в HA
            id(temp_offset_setting).publish_state(x);
            ESP_LOGD("calibration", "Коррекция температуры установлена: %.1f°C", x);
            id(update_display_if_needed).execute();
    lambda: |-
      // При загрузке или запросе от HA возвращаем текущее значение
      return id(temp_offset);

switch:
  - platform: template
    id: auto_brightness
    name: "Автояркость экрана"
    entity_category: config
    icon: "mdi:brightness-auto"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    lambda: |-
      return id(auto_brightness).state;
    turn_on_action:
      then:
        - lambda: |-
            auto call = id(lcd_backlight).turn_on();
            call.set_brightness(1.0);
            call.perform();
    turn_off_action:
      then:
        - lambda: |-
            auto call = id(lcd_backlight).turn_on();
            call.set_brightness(0.5);
            call.perform();
  
  - platform: template
    name: "Автокалибровка CO₂ (ABC)"
    id: abc_co2_switch
    entity_category: diagnostic
    icon: "mdi:calendar-sync"
    optimistic: false
    restore_mode: RESTORE_DEFAULT_OFF  # по умолчанию выключено
    lambda: |-
      // При запуске читаем текущее состояние ABC из датчика
      // Но ESPHome не даёт прямого доступа к этому значению через API
      // Поэтому используем сохранённое значение из глобальной переменной
      return id(abc_enabled);
    turn_on_action:
      then:
        - logger.log: "✅ Автокалибровка CO₂ включена"
        - mhz19.abc_enable: mhz19_sensor
        - lambda: |-
            id(abc_enabled) = true;
            id(abc_co2_switch).publish_state(true);
    turn_off_action:
      then:
        - logger.log: "❌ Автокалибровка CO₂ отключена"
        - mhz19.abc_disable: mhz19_sensor
        - lambda: |-
            id(abc_enabled) = false;
            id(abc_co2_switch).publish_state(false);

# ========== ВЫХОДЫ И СВЕТОДИОДЫ ==========
output:
  - platform: ledc
    id: pwm_red
    pin: GPIO5
    frequency: 1000 Hz
  - platform: ledc
    id: pwm_green
    pin: GPIO18
    frequency: 1000 Hz
  - platform: ledc
    id: pwm_blue
    pin: GPIO19
    frequency: 1000 Hz
  - platform: ledc
    id: pwm_backlight
    pin: GPIO20
    frequency: 5000 Hz

light:
  - platform: rgb
    id: rgb_led
    name: "Внешний RGB"
    red: pwm_red
    green: pwm_green
    blue: pwm_blue
    restore_mode: RESTORE_DEFAULT_ON

  - platform: esp32_rmt_led_strip
    id: builtin_rgb
    name: "Встроенный RGB"
    pin: GPIO8
    num_leds: 1
    rgb_order: GRB
    chipset: ws2812
    restore_mode: RESTORE_DEFAULT_ON
    effects:
      - pulse:
          name: "Пульс"
      - strobe:
          name: "Стробоскоп"

  - platform: monochromatic
    id: lcd_backlight
    name: "Подсветка экрана"
    output: pwm_backlight
    restore_mode: RESTORE_DEFAULT_ON

# ========== ИНТЕРВАЛЫ ==========
interval:
  - interval: 1s
    then:
      - script.execute: update_display_if_needed

  - interval: 5s
    then:
      - script.execute: update_led
      - lambda: |-
          if (id(auto_brightness).state) {
            float light = id(photo_sensor).state;
            float brightness = light > 500 ? 1.0 : (light > 100 ? 0.6 : 0.3);
            auto call = id(lcd_backlight).turn_on();
            call.set_brightness(brightness);
            call.perform();
          }

# ========== ДИСПЛЕЙ С РУССКИМИ БУКВАМИ ==========
display:
  - platform: lcd_pcf8574
    id: my_lcd
    address: 0x27
    dimensions: 20x4
    user_characters:
      - position: 0
        data: [0b11111, 0b10001, 0b10001, 0b10001, 0b10001, 0b10001, 0b10001, 0b00000]  # П
      - position: 1
        data: [0b11111, 0b10000, 0b10000, 0b11111, 0b10001, 0b10001, 0b11111, 0b00000]  # Б
      - position: 2
        data: [0b10001, 0b10001, 0b10001, 0b01111, 0b00001, 0b00001, 0b00001, 0b00000]  # Ч
      - position: 3
        data: [0b10001, 0b10001, 0b10011, 0b10101, 0b11001, 0b10001, 0b10001, 0b00000]  # И
      - position: 4
        data: [0b01110, 0b01010, 0b01010, 0b01010, 0b01010, 0b01010, 0b11111, 0b10001]  # Д
      - position: 5
        data: [0b01111, 0b01001, 0b01001, 0b01001, 0b01001, 0b01001, 0b10001, 0b00000]  # Л
      - position: 6
        data: [0b10101, 0b10101, 0b10101, 0b01110, 0b10101, 0b10101, 0b10101, 0b00000]  # Ж
      - position: 7
        data: [0b00110, 0b01001, 0b01001, 0b00110, 0b00000, 0b00000, 0b00000, 0b00000]  # Градус
    lambda: |-
      it.clear();
      auto time = id(ha_time).now();
      bool time_valid = time.is_valid();
      std::string mode = id(display_mode).current_option();

      if (mode == "Все показания") {
        // Температура с коррекцией
        float raw_temp = id(bme_temperature).state;
        float display_temp = raw_temp + id(temp_offset);
        it.printf(15, 1, "%3.1f\x07", display_temp); // \x07 = градус
        
        // Влажность
        it.printf(16, 0, "%3.0f%%", id(bme_humidity).state);
        
        // Давление
        it.printf(15, 3, "%3.0fmm", id(bme_pressure).state);
        
        // CO2
        float co2_value = id(mhz19_co2).state;
        if (isnan(co2_value)) co2_value = 400;
        it.printf(16, 2, "%4.0f", co2_value);
        
        // День недели и дата
        if (time_valid) {
          int wday = time.day_of_week;
          std::string daytxt = "    ";
          it.print(0, 2, "    ");
          
          switch(wday) {
            case 1: daytxt = "BC"; break;
            case 2: daytxt = "\x08" "H"; break;  // \x08 = П
            case 3: daytxt = "BT"; break;
            case 4: daytxt = "CP"; break;
            case 5: daytxt = "\x02" "T"; break;  // \x02 = Ч
            case 6: daytxt = "\x08" "T"; break;  // \x08 = П
            case 7: daytxt = "C" "\x01"; break;  // \x01 = Б
            default: break;
          }
          it.print(0, 3, daytxt);
          
          it.strftime(3, 3, "%d.%m.%Y", time);
        } else {
          it.print(2, 3, "CHXP...");
        }
        
        // Время
        if (time_valid) {
          char time_str[6];
          sprintf(time_str, "%02d:%02d", time.hour, time.minute);
          it.print(5, 1, time_str);
        } else {
          it.print(5, 1, "--:--");
        }
        
        // WiFi
        if (id(wifi_sta).is_connected()) {
          it.print(15, 0, "\\");
        }
        
      } else if (mode == "Крупно время") {
        if (time_valid) {
          // Время по центру (примерно)
          it.printf(7, 1, "%02d:%02d", time.hour, time.minute);  // строка 1, колонка 7
          
          // Дата в правом нижнем углу
          it.strftime(12, 3, "%d.%m.%Y", time);  // строка 3, колонка 12
        } else {
          it.print(0, 1, "CHXP...");
        }
        
      } else if (mode == "Крупно CO2") {
        it.print(5, 0, "CO2");
        
        float co2_value = id(mhz19_co2).state;
        if (isnan(co2_value)) co2_value = 400;
        it.printf(5, 1, "%d", (int)co2_value);
        
        it.print(5, 2, "ppm");
        if (time_valid) {
          char time_str[6];
          sprintf(time_str, "%02d:%02d", time.hour, time.minute);
          it.print(8, 3, time_str);
        }
        
      } else if (mode == "Таблица символов 1") {
        for (int row = 0; row < 4; row++) {
          for (int col = 0; col < 20; col++) {
            int code = row * 20 + col;
            if (code < 64) {
              it.print(col, row, std::string(1, (char)code));
            }
          }
        }
        it.print(0, 3, "Chars 0-63");
        
      } else if (mode == "Таблица символов 2") {
        for (int row = 0; row < 4; row++) {
          for (int col = 0; col < 20; col++) {
            int code = 64 + row * 20 + col;
            if (code < 128) {
              it.print(col, row, std::string(1, (char)code));
            }
          }
        }
        it.print(0, 3, "Chars 64-127");
        
      } else if (mode == "Таблица символов 3") {
        it.print(0, 0, "User 0-7:");
        for (int i = 0; i < 8; i++) {
          it.print(i*2, 1, std::string(1, (char)i));
          it.print(i*2, 2, std::to_string(i));
        }
        it.print(0, 3, "Mirrors 8-15 same");
      }
